#pragma version 9

// This TEAL was generated by TEALScript v0.63.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its repsective branch will be "NOT_IMPLMENTED" which just contains "err"
txn ApplicationID
int 0
>
int 6
*
txn OnCompletion
+
switch create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_NoOp call_OptIn

NOT_IMPLEMENTED:
	err

optIntoAsset:
	proto 1 0

	// contracts/asset-staker.algo.ts:40
	// sendAssetTransfer({
	//       assetReceiver: this.app.address,
	//       xferAsset: asset,
	//       assetAmount: 0,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/asset-staker.algo.ts:41
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/asset-staker.algo.ts:42
	// xferAsset: asset
	frame_dig -1 // asset: asset
	itxn_field XferAsset

	// contracts/asset-staker.algo.ts:43
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

calculateRewards:
	proto 6 0

	// contracts/asset-staker.algo.ts:50
	// assert(globals.latestTimestamp >= this.startTimestamp.value)
	global LatestTimestamp
	byte 0x7374 // "st"
	app_global_get
	>=
	assert

	// contracts/asset-staker.algo.ts:52
	// assert(this.userLastUpdated(account).value <= this.finishTimestamp.value)
	frame_dig -1 // account: account
	byte 0x756c // "ul"
	app_local_get
	byte 0x6669 // "fi"
	app_global_get
	<=
	assert

	// contracts/asset-staker.algo.ts:54
	// end =
	//       globals.latestTimestamp > this.finishTimestamp.value ? this.finishTimestamp.value : globals.latestTimestamp
	global LatestTimestamp
	byte 0x6669 // "fi"
	app_global_get
	>
	bz ternary1_false
	byte 0x6669 // "fi"
	app_global_get
	b ternary1_end

ternary1_false:
	global LatestTimestamp

ternary1_end:
	frame_bury -2 // end: uint64

	// contracts/asset-staker.algo.ts:57
	// start =
	//       this.userLastUpdated(account).value < this.startTimestamp.value
	//         ? this.startTimestamp.value
	//         : this.userLastUpdated(account).value
	frame_dig -1 // account: account
	byte 0x756c // "ul"
	app_local_get
	byte 0x7374 // "st"
	app_global_get
	<
	bz ternary3_false
	byte 0x7374 // "st"
	app_global_get
	b ternary3_end

ternary3_false:
	frame_dig -1 // account: account
	byte 0x756c // "ul"
	app_local_get

ternary3_end:
	frame_bury -3 // start: uint64

	// contracts/asset-staker.algo.ts:63
	// duration = end - start
	frame_dig -2 // end: uint64
	frame_dig -3 // start: uint64
	-
	frame_bury -4 // duration: uint64

	// contracts/asset-staker.algo.ts:64
	// amountStaked = this.userStake(account).value
	frame_dig -1 // account: account
	byte 0x7573 // "us"
	app_local_get
	frame_bury -5 // amountStaked: uint64

	// contracts/asset-staker.algo.ts:66
	// rewardsEarned = (((amountStaked * duration) / 31557600) * this.rewardRate.value) / 10000
	frame_dig -5 // amountStaked: uint64
	frame_dig -4 // duration: uint64
	*
	int 31557600
	/
	byte 0x7272 // "rr"
	app_global_get
	*
	int 10000
	/
	frame_bury -6 // rewardsEarned: uint64

	// contracts/asset-staker.algo.ts:69
	// this.userPendingRewards(account).value = this.userPendingRewards(account).value + rewardsEarned
	frame_dig -1 // account: account
	byte 0x7570 // "up"
	frame_dig -1 // account: account
	byte 0x7570 // "up"
	app_local_get
	frame_dig -6 // rewardsEarned: uint64
	+
	app_local_put

	// contracts/asset-staker.algo.ts:71
	// this.totalRewards.value = this.totalRewards.value - rewardsEarned
	byte 0x7472 // "tr"
	byte 0x7472 // "tr"
	app_global_get
	frame_dig -6 // rewardsEarned: uint64
	-
	app_global_put

	// contracts/asset-staker.algo.ts:74
	// this.userLastUpdated(account).value = globals.latestTimestamp
	frame_dig -1 // account: account
	byte 0x756c // "ul"
	global LatestTimestamp
	app_local_put

	// contracts/asset-staker.algo.ts:76
	// this.lastUpdated.value = globals.latestTimestamp
	byte 0x6c75 // "lu"
	global LatestTimestamp
	app_global_put
	retsub

// optInToApplication()void
//
// // need this method so user can opt-in to create local state
abi_route_optInToApplication:
	// execute optInToApplication()void
	callsub optInToApplication
	int 1
	return

optInToApplication:
	proto 0 0

	// contracts/asset-staker.algo.ts:81
	// this.userLastUpdated(this.txn.sender).value = 0
	txn Sender
	byte 0x756c // "ul"
	int 0
	app_local_put

	// contracts/asset-staker.algo.ts:82
	// this.userPendingRewards(this.txn.sender).value = 0
	txn Sender
	byte 0x7570 // "up"
	int 0
	app_local_put

	// contracts/asset-staker.algo.ts:83
	// this.userStake(this.txn.sender).value = 0
	txn Sender
	byte 0x7573 // "us"
	int 0
	app_local_put
	retsub

// createApplication()void
abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

createApplication:
	proto 0 0

	// contracts/asset-staker.algo.ts:87
	// this.stakeAsset.value = Asset.zeroIndex
	byte 0x7361 // "sa"
	int 0
	app_global_put

	// contracts/asset-staker.algo.ts:88
	// this.rewardAsset.value = Asset.zeroIndex
	byte 0x7261 // "ra"
	int 0
	app_global_put

	// contracts/asset-staker.algo.ts:89
	// this.totalRewards.value = 0
	byte 0x7472 // "tr"
	int 0
	app_global_put

	// contracts/asset-staker.algo.ts:90
	// this.rewardRate.value = 0
	byte 0x7272 // "rr"
	int 0
	app_global_put

	// contracts/asset-staker.algo.ts:91
	// this.totalStaked.value = 0
	byte 0x7473 // "ts"
	int 0
	app_global_put

	// contracts/asset-staker.algo.ts:92
	// this.startTimestamp.value = 0
	byte 0x7374 // "st"
	int 0
	app_global_put

	// contracts/asset-staker.algo.ts:93
	// this.finishTimestamp.value = 0
	byte 0x6669 // "fi"
	int 0
	app_global_put

	// contracts/asset-staker.algo.ts:94
	// this.lastUpdated.value = 0
	byte 0x6c75 // "lu"
	int 0
	app_global_put
	retsub

// bootstrap(uint64,uint64,asset,asset,pay)void
//
// Allows creator to initialize the app
//
// @param seed The `pay` txn to fund the app (0.2 min)
// @param stakeAsset The asset to be staked
// @param rewardAsset The asset to pay rewards
// @param start The start time in UNIX time
// @param finish The end time in UNIX time
//
// @returns void
abi_route_bootstrap:
	byte 0x; dup // push empty bytes to fill the stack frame for this subroutine's local variables

	// finish: uint64
	txna ApplicationArgs 4
	btoi

	// start: uint64
	txna ApplicationArgs 3
	btoi

	// rewardAsset: asset
	txna ApplicationArgs 2
	btoi
	txnas Assets

	// stakeAsset: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// seed: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute bootstrap(uint64,uint64,asset,asset,pay)void
	callsub bootstrap
	int 1
	return

bootstrap:
	proto 7 0

	// contracts/asset-staker.algo.ts:110
	// assert(start < finish)
	frame_dig -4 // start: uint64
	frame_dig -5 // finish: uint64
	<
	assert

	// contracts/asset-staker.algo.ts:112
	// assert(globals.latestTimestamp < start)
	global LatestTimestamp
	frame_dig -4 // start: uint64
	<
	assert

	// contracts/asset-staker.algo.ts:114
	// verifyTxn(this.txn, { sender: globals.creatorAddress })
	// verify sender
	txn Sender
	global CreatorAddress
	==
	assert

	// contracts/asset-staker.algo.ts:116
	// assert(this.stakeAsset.value === Asset.zeroIndex)
	byte 0x7361 // "sa"
	app_global_get
	int 0
	==
	assert

	// contracts/asset-staker.algo.ts:118
	// assert(this.rewardAsset.value === Asset.zeroIndex)
	byte 0x7261 // "ra"
	app_global_get
	int 0
	==
	assert

	// contracts/asset-staker.algo.ts:120
	// assert(globals.groupSize === 2)
	global GroupSize
	int 2
	==
	assert

	// contracts/asset-staker.algo.ts:122
	// isAssetSame = stakeAsset === rewardAsset
	frame_dig -2 // stakeAsset: asset
	frame_dig -3 // rewardAsset: asset
	==
	frame_bury -6 // isAssetSame: bool

	// contracts/asset-staker.algo.ts:123
	// requiredAmount = isAssetSame ? 2_000 : 3_000
	frame_dig -6 // isAssetSame: bool
	bz ternary5_false
	int 2_000
	b ternary5_end

ternary5_false:
	int 3_000

ternary5_end:
	frame_bury -7 // requiredAmount: uint64

	// contracts/asset-staker.algo.ts:126
	// verifyTxn(seed, { receiver: this.app.address, amount: { greaterThanEqualTo: requiredAmount } })
	// verify receiver
	frame_dig -1 // seed: pay
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // seed: pay
	gtxns Amount
	frame_dig -7 // requiredAmount: uint64
	>=
	assert

	// contracts/asset-staker.algo.ts:128
	// this.optIntoAsset(stakeAsset)
	frame_dig -2 // stakeAsset: asset
	callsub optIntoAsset

	// contracts/asset-staker.algo.ts:129
	// this.stakeAsset.value = stakeAsset
	byte 0x7361 // "sa"
	frame_dig -2 // stakeAsset: asset
	app_global_put

	// if0_condition
	// contracts/asset-staker.algo.ts:131
	// !isAssetSame
	frame_dig -6 // isAssetSame: bool
	!
	bz if0_else

	// if0_consequent
	// contracts/asset-staker.algo.ts:132
	// this.optIntoAsset(rewardAsset)
	frame_dig -3 // rewardAsset: asset
	callsub optIntoAsset

	// contracts/asset-staker.algo.ts:133
	// this.rewardAsset.value = rewardAsset
	byte 0x7261 // "ra"
	frame_dig -3 // rewardAsset: asset
	app_global_put
	b if0_end

if0_else:
	// contracts/asset-staker.algo.ts:135
	// this.rewardAsset.value = stakeAsset
	byte 0x7261 // "ra"
	frame_dig -2 // stakeAsset: asset
	app_global_put

if0_end:
	// contracts/asset-staker.algo.ts:138
	// this.startTimestamp.value = start
	byte 0x7374 // "st"
	frame_dig -4 // start: uint64
	app_global_put

	// contracts/asset-staker.algo.ts:139
	// this.finishTimestamp.value = finish
	byte 0x6669 // "fi"
	frame_dig -5 // finish: uint64
	app_global_put
	retsub

// addRewards(uint64,axfer)uint64
//
// Allows contract to be funded with more rewards
//
// @param axfer The `axfer` funding the app with rewardAsset
// @param rewardRate the uint64 value of how many rewards per second
//
// @returns uint64 - the total rewards (in rewardToken) remaining in the app
abi_route_addRewards:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// rewardRate: uint64
	txna ApplicationArgs 1
	btoi

	// axfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// execute addRewards(uint64,axfer)uint64
	callsub addRewards
	int 1
	return

addRewards:
	proto 3 0

	// contracts/asset-staker.algo.ts:152
	// verifyTxn(this.txn, { sender: globals.creatorAddress })
	// verify sender
	txn Sender
	global CreatorAddress
	==
	assert

	// contracts/asset-staker.algo.ts:155
	// verifyTxn(axfer, {
	//       sender: this.txn.sender,
	//       xferAsset: this.rewardAsset.value,
	//       assetReceiver: this.app.address,
	//       assetAmount: { greaterThan: 0 },
	//     })
	// verify sender
	frame_dig -1 // axfer: axfer
	gtxns Sender
	txn Sender
	==
	assert

	// verify xferAsset
	frame_dig -1 // axfer: axfer
	gtxns XferAsset
	byte 0x7261 // "ra"
	app_global_get
	==
	assert

	// verify assetReceiver
	frame_dig -1 // axfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify assetAmount
	frame_dig -1 // axfer: axfer
	gtxns AssetAmount
	int 0
	>
	assert

	// contracts/asset-staker.algo.ts:162
	// newTotalRewards = this.totalRewards.value + axfer.assetAmount
	byte 0x7472 // "tr"
	app_global_get
	frame_dig -1 // axfer: axfer
	gtxns AssetAmount
	+
	frame_bury -3 // newTotalRewards: uint64

	// contracts/asset-staker.algo.ts:164
	// this.totalRewards.value = newTotalRewards
	byte 0x7472 // "tr"
	frame_dig -3 // newTotalRewards: uint64
	app_global_put

	// contracts/asset-staker.algo.ts:167
	// assert(rewardRate > 0)
	frame_dig -2 // rewardRate: uint64
	int 0
	>
	assert

	// contracts/asset-staker.algo.ts:170
	// this.rewardRate.value = rewardRate
	byte 0x7272 // "rr"
	frame_dig -2 // rewardRate: uint64
	app_global_put

	// contracts/asset-staker.algo.ts:172
	// return newTotalRewards;
	frame_dig -3 // newTotalRewards: uint64
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// addStake(axfer)uint64
//
// Allows users to stake tokens
//
// @param axfer The `axfer` funding the app with stakingAsset
//
// @returns uint64 - the total number of tokens user has staked
abi_route_addStake:
	byte 0x; dup // push empty bytes to fill the stack frame for this subroutine's local variables

	// axfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// execute addStake(axfer)uint64
	callsub addStake
	int 1
	return

addStake:
	proto 3 0

	// contracts/asset-staker.algo.ts:183
	// verifyTxn(axfer, {
	//       sender: this.txn.sender,
	//       xferAsset: this.stakeAsset.value,
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//     })
	// verify sender
	frame_dig -1 // axfer: axfer
	gtxns Sender
	txn Sender
	==
	assert

	// verify xferAsset
	frame_dig -1 // axfer: axfer
	gtxns XferAsset
	byte 0x7361 // "sa"
	app_global_get
	==
	assert

	// verify assetAmount
	frame_dig -1 // axfer: axfer
	gtxns AssetAmount
	int 0
	>
	assert

	// verify assetReceiver
	frame_dig -1 // axfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// contracts/asset-staker.algo.ts:191
	// this.calculateRewards(this.txn.sender)
	byte 0x; dupn 4 // push empty bytes to fill the stack frame for this subroutine's local variables
	txn Sender
	callsub calculateRewards

	// contracts/asset-staker.algo.ts:193
	// amount = axfer.assetAmount
	frame_dig -1 // axfer: axfer
	gtxns AssetAmount
	frame_bury -2 // amount: uint64

	// contracts/asset-staker.algo.ts:196
	// this.totalStaked.value = this.totalStaked.value + amount
	byte 0x7473 // "ts"
	byte 0x7473 // "ts"
	app_global_get
	frame_dig -2 // amount: uint64
	+
	app_global_put

	// contracts/asset-staker.algo.ts:198
	// newUserStake = this.userStake(this.txn.sender).value + amount
	txn Sender
	byte 0x7573 // "us"
	app_local_get
	frame_dig -2 // amount: uint64
	+
	frame_bury -3 // newUserStake: uint64

	// contracts/asset-staker.algo.ts:199
	// this.userStake(this.txn.sender).value = newUserStake
	txn Sender
	byte 0x7573 // "us"
	frame_dig -3 // newUserStake: uint64
	app_local_put

	// contracts/asset-staker.algo.ts:201
	// return newUserStake;
	frame_dig -3 // newUserStake: uint64
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// removeStake(uint64,asset)uint64
//
// Allows users to remove staked tokens
//
// @param asset The stakeTokenAsset (needs implicitly declared?)
//
// @returns uint64 - the total number of tokens user has staked (may be zero if all are removed)
abi_route_removeStake:
	byte 0x; dup // push empty bytes to fill the stack frame for this subroutine's local variables

	// amount: uint64
	txna ApplicationArgs 2
	btoi

	// asset: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute removeStake(uint64,asset)uint64
	callsub removeStake
	int 1
	return

removeStake:
	proto 4 0

	// contracts/asset-staker.algo.ts:213
	// stake = this.userStake(this.txn.sender).value
	txn Sender
	byte 0x7573 // "us"
	app_local_get
	frame_bury -3 // stake: uint64

	// contracts/asset-staker.algo.ts:216
	// assert(amount <= stake)
	frame_dig -2 // amount: uint64
	frame_dig -3 // stake: uint64
	<=
	assert

	// contracts/asset-staker.algo.ts:218
	// assert(asset === this.stakeAsset.value)
	frame_dig -1 // asset: asset
	byte 0x7361 // "sa"
	app_global_get
	==
	assert

	// contracts/asset-staker.algo.ts:221
	// this.calculateRewards(this.txn.sender)
	byte 0x; dupn 4 // push empty bytes to fill the stack frame for this subroutine's local variables
	txn Sender
	callsub calculateRewards

	// contracts/asset-staker.algo.ts:224
	// sendAssetTransfer({
	//       xferAsset: asset,
	//       assetAmount: amount,
	//       assetReceiver: this.txn.sender,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/asset-staker.algo.ts:225
	// xferAsset: asset
	frame_dig -1 // asset: asset
	itxn_field XferAsset

	// contracts/asset-staker.algo.ts:226
	// assetAmount: amount
	frame_dig -2 // amount: uint64
	itxn_field AssetAmount

	// contracts/asset-staker.algo.ts:227
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/asset-staker.algo.ts:231
	// this.totalStaked.value = this.totalStaked.value - amount
	byte 0x7473 // "ts"
	byte 0x7473 // "ts"
	app_global_get
	frame_dig -2 // amount: uint64
	-
	app_global_put

	// contracts/asset-staker.algo.ts:233
	// newUserStake = this.userStake(this.txn.sender).value - amount
	txn Sender
	byte 0x7573 // "us"
	app_local_get
	frame_dig -2 // amount: uint64
	-
	frame_bury -4 // newUserStake: uint64

	// contracts/asset-staker.algo.ts:234
	// this.userStake(this.txn.sender).value = newUserStake
	txn Sender
	byte 0x7573 // "us"
	frame_dig -4 // newUserStake: uint64
	app_local_put

	// contracts/asset-staker.algo.ts:236
	// return newUserStake;
	frame_dig -4 // newUserStake: uint64
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "bootstrap(pay,asset,asset,uint64,uint64)void"
	method "addRewards(axfer,uint64)uint64"
	method "addStake(axfer)uint64"
	method "removeStake(asset,uint64)uint64"
	txna ApplicationArgs 0
	match abi_route_bootstrap abi_route_addRewards abi_route_addStake abi_route_removeStake
	err

call_OptIn:
	method "optInToApplication()void"
	txna ApplicationArgs 0
	match abi_route_optInToApplication
	err